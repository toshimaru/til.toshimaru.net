---
title: 2025-01-10 gRPC vs GraphQL vs REST
categories: architecture
---

gRPC, GraphQL, REST の違いについてまとめてみる（powered by ChatGPT）。

| 項目            | gRPC                            | GraphQL                       |
|----------------|--------------------------------|-------------------------------|
| **プロトコル**   | HTTP/2（バイナリ通信）           | HTTP/1.1, WebSockets（テキスト通信）|
| **データ形式**   | Protobuf（バイナリ、軽量・高速） | JSON（可読性高いが冗長）       |
| **型安全性**     | 高（IDLを使用）                 | 高（スキーマを使用）           |
| **ストリーミング** | 双方向ストリーミングが可能         | リアルタイムはWebSocketsが必要 |
| **主な用途**     | マイクロサービス、バックエンド間通信 | フロントエンドとバックエンド通信 |
| **学習コスト**   | やや高い（IDLの理解が必要）        | 比較的低い（RESTに近い感覚）    |
| **オーバーヘッド**| 低（バイナリ通信）                | やや高（JSONのパース）         |

REST も含めてまとめてみると下記。

| **特徴**                 | **REST**                                                                 | **GraphQL**                                                               | **gRPC**                                                                 |
|--------------------------|--------------------------------------------------------------------------|---------------------------------------------------------------------------|--------------------------------------------------------------------------|
| **通信プロトコル**       | HTTP/HTTPS                                                                | HTTP/HTTPS                                                                 | HTTP/2                                                                    |
| **データフォーマット**   | 主にJSON、XMLも可能                                                      | 主にJSON                                                                   | Protocol Buffers (バイナリ形式)                                           |
| **パフォーマンス**       | 標準的だが、オーバーヘッドが発生する場合がある                           | 必要なデータのみ取得できるため効率的                                     | 高速で効率的な通信が可能                                                 |
| **柔軟性**               | エンドポイントごとに異なるリクエストが必要                                | クライアントが必要なデータを指定できるため高い柔軟性                   | 定義されたサービスとメソッドに基づくが、柔軟性は限定的                 |
| **バージョニング**       | APIバージョンをURLやヘッダーで管理                                      | バージョニングが不要な設計が可能                                         | 通常、バージョニングが必要                                               |
| **ツールサポート**       | 広範なツールとライブラリが存在                                            | 多数の開発ツールやエディタプラグインが利用可能                         | 多言語サポートが充実、特にマイクロサービス向けのツールが豊富           |
| **ストリーミングサポート** | 基本的にサポートされていない（WebSockets等を併用）                     | サポートされているが、RESTほど一般的ではない                             | HTTP/2を活用した効率的なストリーミングが可能                           |
| **キャッシング**         | HTTPのキャッシングメカニズムを利用可能                                  | キャッシングが複雑（クエリが柔軟なため）                                | 標準的なHTTPキャッシングは難しいが、独自のキャッシング戦略が可能       |
| **セキュリティ**         | HTTPSを利用したセキュリティ、認証はOAuthなどを利用                      | HTTPSを利用したセキュリティ、認証はRESTと同様                           | TLSによるセキュリティが標準、認証はトークンベースが一般的               |
| **学習曲線**             | 比較的シンプルで学習しやすい                                             | クエリ言語やスキーマ設計など、学習がやや必要                             | Protocol Buffersの理解やサービス定義が必要、学習曲線はやや急             |
| **主なユースケース**     | ウェブAPI全般、マイクロサービス、シンプルなデータ取得                     | クライアントが複雑なデータを必要とするアプリケーション（例：フロントエンド） | マイクロサービス間通信、高性能なリアルタイムアプリケーション、モバイルバックエンド |
